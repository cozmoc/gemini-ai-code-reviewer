gemini-1.5-pro-002import os
import json
import time
import logging
from typing import List, Dict, Any
from github import Github
from unidiff import PatchSet

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Environment variables
GITHUB_TOKEN = os.environ.get("GITHUB_TOKEN")
GITHUB_EVENT_PATH = os.environ.get("GITHUB_EVENT_PATH")
INPUT_BATCH_SIZE = int(os.environ.get("HUNK_BATCH_SIZE", 5))
MAX_RETRIES = int(os.environ.get("MAX_RETRIES", 3))
MAX_SUGGESTIONS = int(os.environ.get("MAX_SUGGESTIONS", 1))
MAX_COMMENTS = int(os.environ.get("MAX_COMMENTS", 4))
GEMINI_MODEL = os.environ.get("GEMINI_MODEL", "gemini-1.5-pro-002")

# Initialize clients
github_client = Github(GITHUB_TOKEN)

# Gemini client stub (replace with real implementation)
def call_gemini(prompt: str) -> List[Dict[str, Any]]:
    # Stubbed API call
    return [{"body": "Consider refactoring this function.", "file": "example.py", "line": 42, "suggestion": True}]


# === Class Definitions ===
class PRDetails:
    def __init__(self, owner: str, repo: str, number: int, title: str, description: str):
        self.owner = owner
        self.repo = repo
        self.number = number
        self.title = title
        self.description = description


# === Step 3: Get PR Metadata ===
def get_pr_details() -> PRDetails:
    with open(GITHUB_EVENT_PATH, 'r') as f:
        event = json.load(f)

    repo_full = event['repository']['full_name']
    owner, repo = repo_full.split('/')
    number = event['issue']['number']
    title = event['issue'].get('title', '')
    description = event['issue'].get('body', '')

    return PRDetails(owner, repo, number, title, description)


# === Step 4: Call Gemini AI ===
def get_ai_response(prompt: str) -> List[Dict[str, Any]]:
    for i in range(MAX_RETRIES):
        try:
            return call_gemini(prompt)
        except Exception as e:
            logger.warning(f"Gemini API call failed: {e}. Retrying ({i+1}/{MAX_RETRIES})...")
            time.sleep(2 ** i)
    return []


# === Step 5: Analyze PR Diffs ===
def analyze_code(parsed_diffs: PatchSet, pr: PRDetails) -> List[Dict[str, Any]]:
    hunks = []
    for patched_file in parsed_diffs:
        for hunk in patched_file:
            hunks.append({
                "file": patched_file.path,
                "hunk": str(hunk),
                "hunk_obj": hunk,
            })

    reviews = []
    for i in range(0, len(hunks), INPUT_BATCH_SIZE):
        batch = hunks[i:i + INPUT_BATCH_SIZE]
        prompt = create_batch_prompt(batch, pr)
        response = get_ai_response(prompt)
        for r in response:
            if len(reviews) < MAX_COMMENTS:
                reviews.append(r)

    return reviews


# === Step 6: Create Review Prompt ===
def create_batch_prompt(batch, pr: PRDetails) -> str:
    diff_text = "\n".join(h["hunk"] for h in batch)
    return f"""Pull Request: {pr.title}
Description: {pr.description}
Please review the following diff and provide feedback:

{diff_text}
"""


# === Step 7: Format Comment Body ===
def wrap_body(review: Dict[str, Any]) -> str:
    if review.get("suggestion"):
        return f"```suggestion\n{review['body']}\n```"
    return review["body"]


# === Step 8: Post AI Review to GitHub ===
def create_review_comment(owner: str, repo: str, pr_number: int, reviews: List[Dict[str, Any]]):
    repo = github_client.get_repo(f"{owner}/{repo}")
    pull = repo.get_pull(pr_number)

    comments = []
    for r in reviews:
        comments.append({
            "path": r["file"],
            "body": wrap_body(r),
            "line": r["line"],
            "side": "RIGHT",
        })

    if comments:
        pull.create_review(body="AI-generated code review suggestions", event="COMMENT", comments=comments)


# === Step 9: Main Entrypoint ===
def main():
    event_type = os.environ.get("GITHUB_EVENT_NAME")
    if event_type != "issue_comment":
        logger.info("Not triggered by issue_comment event.")
        return

    pr = get_pr_details()
    repo = github_client.get_repo(f"{pr.owner}/{pr.repo}")
    pull = repo.get_pull(pr.number)
    files = pull.get_files()
    
    raw_diff = ""
    for f in files:
        raw_diff += f.patch or ""

    parsed = PatchSet(raw_diff)
    reviews = analyze_code(parsed, pr)

    if reviews:
        create_review_comment(pr.owner, pr.repo, pr.number, reviews)
    else:
        logger.info("No suggestions generated by AI.")


if __name__ == "__main__":
    main()
